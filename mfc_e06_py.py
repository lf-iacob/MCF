# -*- coding: utf-8 -*-
"""MFC_E06.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ckWkJQzChtmlbtUJUmPX6cQop4awvrIo

#MCF_E06: Integrazione e Derivazione
"""

# Import
import numpy as np
import pandas as pd
import scipy as sp
from scipy import integrate
import matplotlib.pyplot as plt

"""##1_legge_oraria.py"""

#estrazione dati
tab=pd.read_csv('https://raw.githubusercontent.com/s-germani/metodi-computazionali-fisica-2024/refs/heads/main/dati/integrazione_derivazione/vel_vs_time.csv')
t=tab['t']
v=tab['v']
print(tab)

#grafico velocita
plt.figure()
plt.plot(t, v, color='teal')
plt.title('Andamento della velocità')
plt.xlabel('Tempo [s]')
plt.ylabel('Velocità [m/s]')
plt.grid()
plt.show()

#integrazione
simp=np.empty(0)
for i in range(1, len(v)+1):
  integ=integrate.simpson(v[0:i], t[0:i])
  simp=np.append(simp, integ)

#grafico legge oraria
plt.figure()
plt.plot(t, simp, color='orchid')
plt.title('Legge oraria')
plt.ylabel('Legge oraria [m]')
plt.xlabel('Tempo [s]')
plt.grid()
plt.show()

"""##2_oscillatore_anarmonico.py"""

k=float(input('Inserire costante moltiplicativa k: '))
m=float(input('Inserire massa m: '))

def f(x0, x):
  return np.sqrt(8*m)/np.sqrt(abs(potenziale_0(x0)-potenziale_0(x)))

x0=int(input('Si scelga il punto di rilascio della pallina: '))
x=np.arange(-x0, x0+0.1, 0.1)
y=np.arange(0, x0)

"""###$\text{Potenziale_0: }V_0=kx^6$"""

def potenziale_0(x):
  return k*x**6
v0=potenziale_0(x)

plt.figure()
plt.plot(x, v0, color='teal')
plt.xlabel('x')
plt.ylabel('V(x)')
plt.grid()
plt.title('Potenziale V0')
plt.show()

#integro tra 0 e x0
intervallo0=np.arange(0, x0, 0.5)
T0=integrate.simpson(f(x0, intervallo0), intervallo0)
print('Periodo di oscillazione: {:} s'.format(T0))

#vario x0
dT0=np.empty(0)
for i in range(1, x0+1):
  intervallo_i0=np.arange(0, i)
  dT0=np.append(dT0, integrate.simpson(f(i, intervallo_i0), intervallo_i0))
print(dT0)

#vario x0
plt.figure()
plt.title('Periodo al variare del punto di partenza: V0')
plt.plot(y, dT0, color='teal')
plt.xlabel('x0 [m]')
plt.ylabel('Periodo di oscillazione [s]')
plt.grid()
plt.show()

"""###$\text{Potenziale_1: }V_1=kx^4$"""

def potenziale_1(x):
  return k*x**4
v1=potenziale_1(x)

plt.figure()
plt.plot(x, v1, color='purple')
plt.xlabel('x')
plt.ylabel('V(x)')
plt.grid()
plt.title('Potenziale V1')
plt.show()

#integro tra 0 e x0
intervallo1=np.arange(0, x0, 0.5)
T1=integrate.simpson(f(x0, intervallo1), intervallo1)
print('Periodo di oscillazione: {:} s'.format(T1))

#vario x0
dT1=np.empty(0)
for i in range(1, x0+1):
  intervallo_i1=np.arange(0, i)
  dT1=np.append(dT1, integrate.simpson(f(i, intervallo_i1), intervallo_i1))
print(dT1)

#vario x0
plt.figure()
plt.title('Periodo al variare del punto di partenza: V1')
plt.plot(y, dT1, color='purple')
plt.xlabel('x0 [m]')
plt.ylabel('Periodo di oscillazione [s]')
plt.grid()
plt.show()

"""###$\text{Potenziale_2: }V_2=k{|x|}^{3/2}$"""

def potenziale_2(x):
  return k*abs(x)**(5/2)
v2=potenziale_2(x)

plt.figure()
plt.plot(x, v2, color='mediumspringgreen')
plt.xlabel('x')
plt.ylabel('V(x)')
plt.grid()
plt.title('Potenziale V2')
plt.show()

#integro tra 0 e x0
intervallo2=np.arange(0, x0, 0.5)
T2=integrate.simpson(f(x0, intervallo2), intervallo2)
print('Periodo di oscillazione: {:} s'.format(T2))

#vario x0
dT2=np.empty(0)
for i in range(1, x0+1):
  intervallo_i2=np.arange(0, i)
  dT2=np.append(dT2, integrate.simpson(f(i, intervallo_i2), intervallo_i2))
print(dT2)

#vario x0
plt.figure()
plt.title('Periodo al variare del punto di partenza: V2')
plt.plot(y, dT2, color='mediumspringgreen')
plt.xlabel('x0 [m]')
plt.ylabel('Periodo di oscillazione [s]')
plt.grid()
plt.show()

"""###Confronto potenziali 0,1,2"""

T=np.array([T0, T1, T2])
print('Periodi a x0: \nT0: {:} \nT1: {:} \nT2: {:}'.format(T[0], T[1], T[2]))

plt.figure()
plt.plot(x, v0, color='teal', label='V0')
plt.plot(x, v1, color='purple', label='V1')
plt.plot(x, v2, color='mediumspringgreen', label='V2')
plt.xlabel('x')
plt.ylabel('V(x)')
plt.ylim(0, v2[len(v2)-1])
plt.grid()
plt.legend()
plt.title('Potenziali')
plt.show()

#vario x0
plt.figure()
plt.title('Periodo al variare del punto di partenza')
plt.plot(y, dT0, color='teal', label='V0', lw=9)
plt.plot(y, dT1, color='purple', label='V1', lw=5)
plt.plot(y, dT2, color='mediumspringgreen', label='V2', lw=1)
plt.xlabel('x0 [m]')
plt.ylabel('Periodo di oscillazione [s]')
plt.legend()
plt.grid()
plt.show()

"""##3_oscilloscopio.py"""

#Estrazione dei dati csv
tab=pd.read_csv('https://raw.githubusercontent.com/s-germani/metodi-computazionali-fisica-2024/refs/heads/main/dati/integrazione_derivazione/oscilloscope.csv')
print(tab)

t=tab['time']
s1=tab['signal1']
s2=tab['signal2']

#grafico dei segnali
plt.figure(figsize=(12,5))
plt.title("Segnali dell'oscilloscopio")
plt.plot(t, s1, color='cornflowerblue', label='Segnale 1')
plt.plot(t, s2, color='hotpink', label='Segnale 2')
plt.xlabel('Tempo [s]')
plt.ylabel('Volt [V]')
plt.legend()
plt.grid()
plt.show()

#DERIVATA con metodo della Differenza Centrale (con DATI RUMOROSI)
def derivata(x, y, n):
  ris=np.empty(0)
  new_x=np.empty(0)
  for i in range(int(n/2), int(len(t)-1-n/2), n):
    ris=np.append(ris, (y[i+n/2]-y[i-n/2])/(x[i+n/2]-x[i-n/2]))
    new_x=np.append(new_x, x[i])
  return new_x, ris

#Calcolo le derivate dei due segnali ruomorosi dell'oscilloscopio
t1, ds1=derivata(t, s1, 4)
t2, ds2=derivata(t, s2, 4)

#grafico le derivate dei segnali
plt.figure(figsize=(12,5))
plt.title("Derivate dei segnali dell'oscilloscopio: n=4")
plt.plot(t1, ds1, color='cornflowerblue', label='Segnale 1')
plt.plot(t2, ds2, color='hotpink', label='Segnale 2')
plt.xlabel('Tempo [s]')
plt.ylabel('Volt/tempo [$dV/dt$]')
plt.legend()
plt.grid()
plt.show()

#Calcolo le derivate dei due segnali ruomorosi dell'oscilloscopio
t1, ds1=derivata(t, s1, 50)
t2, ds2=derivata(t, s2, 50)

#grafico le derivate dei segnali
plt.figure(figsize=(12,5))
plt.title("Derivate dei segnali dell'oscilloscopio: n=50")
plt.plot(t1, ds1, color='cornflowerblue', label='Segnale 1')
plt.plot(t2, ds2, color='hotpink', label='Segnale 2')
plt.xlabel('Tempo [s]')
plt.ylabel('Volt/tempo [$dV/dt$]')
plt.legend()
plt.grid()
plt.show()